/************* https://nodejs.org/api/errors.html ********************/

There are four type of error can be categorise in nodejs
1. Standard JavaScript errors
    a. <EvalError> : thrown ehrn a call to eval() fails.
    b. <SyntaxError> : thrown in response to improper JavaScript language syntax
    c. <RangeError> : thrown  when the value is not expected within the range
    d. <ReferenceError> : thrown  when using undefined variable
    e. <TypeError> : thrown when passing arguments of the wrong type
    f. <URIError> : thrown  when a global URI handling function is missused
2. System errors triggered by underlying operating system constraints
    a. attempting to open a file that does not exist
    b. attempting to send data over a closed socket
    c. etc
3. User specific errors triggered by application code
4. Assertion Errors: errors which can be triggered whenever Nodejs detects an exceptional logic violation that should never occure. 
These are typically raised in assert module.

-------------------------------------------------------------------------------------------------------------
/************** try / catch **********************/
try{
    const m =1;
    const n =m+z;

    console.log('Test..................');
}
catch(err)
{
    console.log(new Error('Variable not decalred, Error details are \n ' + err));
}
console.log('hiiiiiiiiiiiiiiiiiii');

/*************** Asynchronous methods that accept a callback function    ********************/
/**
Most asynchronous methods that accept a callback function will accept an Error object passed as the first argument to that function.
If that first argument is not null and is an instance of Error, then an error occurred that should be handled.
*/

const fs = require('fs'),
        path = require('path'),
        filePath= path.join(__dirname, 'start1.html');

fs.readFile(filePath, {encoding: 'utf-8'}, function(err,data){
    if (!err) {
        console.log('received data: ' + data);
        //response.writeHead(200, {'Content-Type': 'text/html'});
        //response.write(data);
        //response.end();
        console.log(data);
    } else {
        console.log(err);
    }
});

/**
When an asynchronous method is called on an object that is an EventEmitter, erros can be routed to that object's 'error' event.
*/

const net = require('net');
const connection= net.connect('https://nodejs.org/api/errors.html');

connection.on('error',(err)=>{
  console.error(err.message);    
})

connection.pipe(process.stdout);
console.log('Event Emitter');


/****************** Error routed to objects 'events' error   ****************************/

const EventEmitter = require('events');
const ee = new EventEmitter();

setImmediate(() => {
  // This will crash the process because no 'error' event
  // handler has been added.
  ee.emit('error', new Error('This will crash'));
});
---------------------------------------------------------------------------------------------
/************************ Error First callback ****************************/
/**
*Most asynchronous method exposed by the Node.js core API follow an idiomatic pattern reffered to as an error-first callback.
*With idiomatic pattern, a callback function is passed to the method as argument. When the operation either complete or an error is raised, 
* the callback function is called with the Error object(if any) passed as the first argument. If no error was raised, the first argument will be passed as null.
*/

const fs = require('fs'),
      path = require('path'),
        filePath= path.join(__dirname, 'start.html');
        filePath2=path.join(__dirname, 'start1.html');

function errorFirstCallback(err,data){
  if(err){
    console.error('There was an error',err);
    return;
  }
  console.log(data);
}

console.log('call file which exists!');
fs.readFile(filePath,errorFirstCallback);
console.log('Call file does not exists!');
fs.readFile(filePath2,errorFirstCallback);

/**
* The JavaScript try/ catch mechanism cannot be used to intercept errors generated by asynchronous APIs.
* A common mistake for beginners is to try to use throw inside an error-first callback.
**/

const fs = require('fs'),
      path = require('path'),
        filePath= path.join(__dirname, 'start.html');
        filePath2=path.join(__dirname, 'start1.html');
try
{
  fs.readFile(filePath2,(err,data)=>{
    if(err){
      //console.log(err);
    throw err;
    }
  });
}catch(err){
  console.error(err);
}

/**
* The above will not work because the callback function passed to fs.readFile() is called asynchronously.
* If domains are enables, or a handler has been registered with process.on('uncaughtException'), such errors can be intercepted.
**/

/************************ Class: Error ****************************/


/************************ Morgan *****************************/
1. Morgan is use for logging machanism, but it is doing more than that
2. npm install --save morgan 
3. Morgan behind the sence call the next function saying i didnot response, let's continue This

const morgan = require('morgan');
app.use(morgan(dev));

4. In above line dev is the format
